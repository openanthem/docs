[[configuration-mapping-configuring-a-mapping]]
= Configuring a Mapping
The process for defining a mapping between params is relatively straightforward.  See the following example:

.Sample Core Entity
[source,java]
----
@Domain("sample_core", includeListeners = { ListenerType.persistence })
@Repo(value = Database.rep_mongodb, cache = Cache.rep_device)
@Getter @Setter @ToString
public class SampleCoreEntity {
    
    private String name;
}
----

This class represents the definition of our *core domain entity*. Params created from this defintion will be mapped to from view Params.

.Sample View Entity 1
[source,java]
----
@Domain(value="sample_view1", includeListeners = { ListenerType.websocket })
@Repo(Database.rep_none)
@MapsTo.Type(SampleCoreEntity.class)
public class VRSampleView1 {

    // Page/Tile/Section/Form declarations omitted for brevity.    

    @Model @Getter @Setter
    @MapsTo.Type(SampleCoreEntity.class)
    public static class SampleForm {

        @TextBox
        @MapsTo.Path
        @Label("Enter name: ")
        private String name;
    }
}
----

This class represents the definition of a *view domain entity*. Notice that both `VRSampleView1` and `SampleForm` map to `SampleCoreEntity.class`. Now that `name` is decorated with `@MapsTo.Path`, the Framework knows that the textbox component defined at `SampleForm.name` is mapped to `SampleCoreEntity.name`. Hence the value displayed in the textbox would be equal to the state found in `SampleCoreEntity.name`.

.Sample View Entity 2
[source,java]
----
@Domain(value="sample_view2", includeListeners = { ListenerType.websocket })
@MapsTo.Type(SampleCoreEntity.class)
@Repo(Database.rep_none)
public class VRSampleView2 {

    // Page/Tile/Section/Form declarations omitted for brevity.  

    @Model @Getter @Setter
    @MapsTo.Type(SampleCoreEntity.class)
    public static class SampleForm {

        @FieldValue
        @MapsTo.Path("name")
        @Label("Hello: ")
        private String personName;
    }
}
----

This class represents another definition of a *view domain entity*. In this scenario, note that `SampleForm.personName` is decorated with `@MapsTo.Path("name")`, the Framework knows that the field value component defined at `SampleForm.personName` is mapped to `SampleCoreEntity.name`. Hence the value displayed in the field value component would be equal to the state found in `SampleCoreEntity.name`.

Both of these scenarios illustrates the ability to create one or more views for a core domain entity, which is a very typical scenario when displaying data in any application. This allows users of the Framework to re-use core domain data using a multitude of views, using whichever components are necessary to achieve specific funtionality.

For more information on the `@MapsTo.Path` and `@MapsTo.Type` annotations, see the <<core-config-annotation-maps-to>> section.